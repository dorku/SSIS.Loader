/* ScriptLoader.cs
 * SSIS Script Loader by Karan Misra (kid0m4n)
 */

using System;
using System.Data;
using System.Linq;
using System.Collections.Generic;
using Microsoft.SqlServer.Dts.Runtime;
using System.Data.SqlClient;
using System.Text;
using System.Threading;
using System.Data.Common;
using System.Data.OleDb;
using System.IO;
using System.Collections;

namespace ST_6df146e709f5496ab83a8452be3f0685.csproj
{
    [System.AddIn.AddIn("ScriptMain", Version = "1.0", Publisher = "", Description = "")]
    public partial class ScriptMain : Microsoft.SqlServer.Dts.Tasks.ScriptTask.VSTARTScriptObjectModelBase
    {
        #region VSTA generated code
        enum ScriptResults
        {
            Success = Microsoft.SqlServer.Dts.Runtime.DTSExecResult.Success,
            Failure = Microsoft.SqlServer.Dts.Runtime.DTSExecResult.Failure
        };
        #endregion

        private string _packageName;
        private string _taskName;
        private string _version;

        private string _batchId;
        private string _loadingTableConn;
        private string _loggingTableConn;
        private int _totalThreads;
        private int _commitInterval;
        private int _bufferLength;

        private bool _loadLogging;
        private int _loadLoggingInterval;
        private int _loggingLevel;
        private bool _doProfiling;

        private string _badFilesPath;
        private int _totalBadLines;
        private char _badFileSeparator;

        private string _connDelimiter;
        private string _connections;
        private Dictionary<string, string> _connectionStrings = new Dictionary<string, string>();

        private int _recoveryBatchSize;

        private int _errorThreshold;

        private T GetVariable<T>(string varName)
        {
            if (Dts.Variables.Contains(varName))
                return (T)Dts.Variables[varName].Value;
            else
                throw new ApplicationException("Variable {0} not found.".FormatWith(varName));
        }

        private T GetVariable<T>(string varName, T defaultValue)
        {
            if (Dts.Variables.Contains(varName))
                return (T)Dts.Variables[varName].Value;
            else
                return defaultValue;
        }

        /// <summary>
        /// Initialize the variables as they are mapped from SSIS.
        /// </summary>
        private void InitVariables()
        {
            // This is the package name of the calling package.
            _packageName = (string)Dts.Variables["v_MasterPackageName"].Value;
            _taskName = (string)Dts.Variables["TaskName"].Value;
            _version = "{0}.{1}.{2}".FormatWith(
                Dts.Variables["VersionMajor"].Value,
                Dts.Variables["VersionMinor"].Value,
                Dts.Variables["VersionBuild"].Value);

            _batchId = (string)Dts.Variables["v_BatchID"].Value;

            _loadingTableConn = (string)Dts.Variables["v_LoadingTableConn"].Value;
            _loggingTableConn = (string)Dts.Variables["v_LoggingTableConn"].Value;
            _totalThreads = (int)Dts.Variables["v_TotalThreads"].Value;
            _commitInterval = GetVariable<int>("v_CommitInterval", 100000);

            _bufferLength = GetVariable<int>("v_BufferLength", 10000);

            _loadLogging = (bool)Dts.Variables["v_LoadLogging"].Value;
            _loadLoggingInterval = (int)Dts.Variables["v_LoadLoggingInterval"].Value;
            _loggingLevel = (int)Dts.Variables["v_LoggingLevel"].Value;

            _doProfiling = (bool)Dts.Variables["v_DoProfiling"].Value;

            _recoveryBatchSize = GetVariable<int>("v_RecoveryBatchSize", 2);

            _badFilesPath = GetVariable<string>("v_BadFilesPath", Path.GetTempPath());
            _totalBadLines = GetVariable<int>("v_TotalBadLines", 10);
            _badFileSeparator = (char)GetVariable<ushort>("v_BadFileSeparator", ',');

            _connDelimiter = GetVariable<string>("v_ConnDelimiter");
            _connections = GetVariable<string>("v_Connections");

            _errorThreshold = GetVariable<int>("v_ErrorThreshold", 20);

            foreach (var conn in _connections.Split(new string[] { _connDelimiter + _connDelimiter }, StringSplitOptions.None))
            {
                var twoParts = conn.Split(_connDelimiter[0]);
                if (twoParts.Length != 2)
                    throw new ApplicationException("Connection string is not formatted properly. Name and string should be separated by #");
                else
                    _connectionStrings.Add(twoParts[0], twoParts[1]);
            }
        }

        /// <summary>
        /// Classify the different types of messages generated by the script.
        /// </summary>
        private enum InfoType { Load, Misc, Error }

        /// <summary>
        /// Write info generated by the script.
        /// </summary>
        /// <param name="logType">The level of information generated.</param>
        /// <param name="message">The actual info message.</param>
        /// <param name="args">Parameters for formatting.</param>
        private void WriteInfo(InfoType logType, string message, params object[] args)
        {
            // Decide whether to proceed based on the current logging level.
            // Ex: Misc messages are not output if the logging level is < 1.
            switch (logType)
            {
                case InfoType.Load:
                case InfoType.Error:
                    break;
                case InfoType.Misc:
                    if (_loggingLevel < 1)
                        return;
                    else
                        break;
            }

            bool temp = false;
            string processedMessage = message.FormatWith(args);

            // We fire an error or information based on the type of info.
            switch (logType)
            {
                case InfoType.Load:
                case InfoType.Misc:
                    Dts.Events.FireInformation(0, "", processedMessage, "", 0, ref temp);
                    break;

                case InfoType.Error:
                    Dts.Events.FireInformation(0, "", processedMessage, "", 0, ref temp);
                    Thread.VolatileWrite(ref _totalErrors, _totalErrors + 1);
                    break;
            }
        }

        /// <summary>
        /// Queue to hold tasks.
        /// </summary>
        Queue<LoadTask> _loadTasks = null;
        List<Conversion> _conversions;

        /// <summary>
        /// Get row count of a table using a OleDbConnection.
        /// </summary>
        /// <param name="tableName">Name of table from which to fetch info.</param>
        /// <param name="conn">The OleDbConnection to use to connect to the database.</param>
        /// <returns>Row count of the table.</returns>
        private int GetRowCount(string tableName, string query, OleDbConnection conn)
        {
            // Get row count.
            if (query != null)
            {
                using (var cmd = GetCommand<OleDbCommand, OleDbConnection>("SELECT COUNT(*) FROM ({0}) A".FormatWith(query), conn))
                {
                    // No time out.
                    cmd.CommandTimeout = 0;

                    return Int32.Parse(cmd.ExecuteScalar().ToString());
                }
            }
            else
            {
                using (var cmd = GetCommand<OleDbCommand, OleDbConnection>("SELECT COUNT(*) FROM {0}".FormatWith(tableName), conn))
                {
                    // No time out.
                    cmd.CommandTimeout = 0;

                    return Int32.Parse(cmd.ExecuteScalar().ToString());
                }
            }
        }

        /// <summary>
        /// Get row count of a table using a SqlConnection.
        /// </summary>
        /// <param name="tableName">Name of table from which to fetch info.</param>
        /// <param name="conn">The SqlConnection to use to connect to the database.</param>
        /// <return>Row count of the table.</return></returns>
        private int GetRowCount(string tableName, string query, SqlConnection conn)
        {
            // Get row count.

            if (query != null)
            {
                using (var cmd = GetCommand<SqlCommand, SqlConnection>("SELECT COUNT(*) FROM ({0}) A".FormatWith(query), conn))
                {
                    // No time out.
                    cmd.CommandTimeout = 0;

                    return Int32.Parse(cmd.ExecuteScalar().ToString());
                }
            }
            else
            {
                using (var cmd = GetCommand<SqlCommand, SqlConnection>("SELECT COUNT(*) FROM {0}".FormatWith(tableName), conn))
                {
                    // No time out.
                    cmd.CommandTimeout = 0;

                    return Int32.Parse(cmd.ExecuteScalar().ToString());
                }
            }
        }

        /// <summary>
        /// Get the connection string from the different repositories.
        /// </summary>
        /// <param name="conn">Identifier to retrieve using.</param>
        /// <returns>Connection string.</returns>
        private string ResolveConnString(string conn)
        {
            if (_connectionStrings.ContainsKey(conn))
                return _connectionStrings[conn];
            else
                throw new ApplicationException("Connection string not resolved for {0}.".FormatWith(conn));
        }

        public class Column
        {
            public string Name { get; set; }
            public string DataType { get; set; }
            public int Length { get; set; }
            public bool IsNullAllowed { get; set; }



            public override string ToString()
            {
                return "{0} ({1},{2},{3})".FormatWith(Name, DataType, Length, IsNullAllowed ? "NULL" : "NOT NULL");
            }
        }

        private bool CanConvertTo(Column from, Column to)
        {
            return from != null && to != null &&
                from.Name.Equals(to.Name, StringComparison.CurrentCultureIgnoreCase) &&
                ((from.DataType == to.DataType && from.Length == to.Length) ||
                _conversions.Count(pc => pc.SourceType == from.DataType && pc.TargetType == to.DataType) == 1);
        }

        /// <summary>
        /// Get schema (column) information for a particular table.
        /// </summary>
        /// <param name="cmd">Prepared IDbCommand containing a SELECT * FROM TABLE</param>
        /// <returns>List of column names returned from the executed query.</returns>
        private List<Column> CollectSchema(DbCommand cmd)
        {
            using (var rdr = cmd.ExecuteReader(CommandBehavior.SchemaOnly))
            {
                DataTable tbl = rdr.GetSchemaTable();

                var colList = new List<Column>();

                for (var i = 0; i < rdr.VisibleFieldCount; i++)
                    colList.Add(
                        new Column
                        {
                            Name = rdr.GetName(i),
                            DataType = rdr.GetDataTypeName(i),
                            Length = (int)tbl.Rows[i]["ColumnSize"],
                            IsNullAllowed = (bool)tbl.Rows[i]["AllowDBNull"]
                        });

                return colList;
            }
        }

        private T GetConnection<T>(string connName) where T : DbConnection, new()
        {
            var conn = new T();
            conn.ConnectionString = ResolveConnString(connName);
            conn.Open();

            return conn;
        }

        private void CloseConnection<T>(ref T conn) where T : DbConnection
        {
            if (conn != null)
            {
                conn.Close();
                conn.Dispose();

                conn = null;
            }
        }

        private TCmd GetCommand<TCmd, TConn>(string cmdStr, TConn conn)
            where TCmd : DbCommand, new()
            where TConn : DbConnection
        {
            var cmd = new TCmd();
            cmd.Connection = conn as TConn;
            cmd.CommandText = cmdStr;
            cmd.CommandTimeout = 0;

            return cmd;
        }

        private SqlBulkCopy PrepareBulkCopy(SqlConnection conn, int batchSize, string destination, List<SqlBulkCopyColumnMapping> columnMappings)
        {
            var bulkCopy = new SqlBulkCopy(conn, SqlBulkCopyOptions.KeepNulls | SqlBulkCopyOptions.TableLock, null) { BatchSize = batchSize, DestinationTableName = destination, BulkCopyTimeout = 0 };

            if (columnMappings != null)
                foreach (var mapping in columnMappings)
                    bulkCopy.ColumnMappings.Add(mapping);

            // If we are going to do load logging, setup the bulk copy process as required.
            if (_loadLogging)
            {
                bulkCopy.NotifyAfter = _loadLoggingInterval;
                bulkCopy.SqlRowsCopied += new SqlRowsCopiedEventHandler((o, args) =>
                {
                    WriteInfo(InfoType.Load, "{0} rows loaded to {1}.", _loadLoggingInterval, (o as SqlBulkCopy).DestinationTableName);
                });
            }

            return bulkCopy;
        }

        private void BufferedBulkLoadTable(OleDbCommand rdrCommand, string sourceTable, List<Column> sourceColumns, string[] commonColumnNames, SqlConnection targetConn, string targetTable, List<SqlBulkCopyColumnMapping> columnMappings, int commitInterval, out DateTime startTime, out DateTime endTime, out int totalRows)
        {
            using (var bulkCopy = PrepareBulkCopy(targetConn, commitInterval, targetTable, columnMappings))
            {
                // Record start time.
                startTime = DateTime.Now;
                totalRows = 0;

                try
                {
                    // Ensure that we dispose the reader.
                    using (var rdr = new DecoradedReader(new ConvertingReader(rdrCommand.ExecuteReader()), commitInterval))
                    {
                        // Only proceed if we have input rows coming along.
                        // Wont be harmful to proceed, but wasted execution time.
                        if (rdr.HasRows)
                        {
                            // Mark the starting of the main copy routine.
                            WriteInfo(InfoType.Misc, "Buffered load for {0} starting.", targetTable);

                            StreamWriter badFile = null;
                            string insertStatement = null;
                            var totalBadRows = 0;
                            object[] badData = new object[rdr.FieldCount + 1];

                            do
                            {
                                try
                                {
                                    bulkCopy.WriteToServer(rdr);

                                    if (!rdr.HitBufferLimit)
                                        break;
                                }
                                catch (Exception e)
                                {
                                    if (e.Message.Contains("Received an invalid column length from the bcp client"))
                                    {
                                        throw;
                                    }

                                    if (badFile == null)
                                    {
                                        badFile = GetBadFileWriter(targetTable, startTime);

                                        var header = new List<string>(sourceColumns.Select(x => x.Name));
                                        header.Add("Error Description");

                                        badFile.WriteLine(header.Aggregate((x, y) => "{0}{1}{2}".FormatWith(x, _badFileSeparator, y)));

                                        var i = 0;
                                        insertStatement = "insert into {0} ({1}) values ({2})".FormatWith(targetTable, commonColumnNames.Aggregate((x, y) => x + "," + y), commonColumnNames.Select(x => "@p" + i++).Aggregate((x, y) => x + "," + y));
                                    }

                                    using (var cmd = GetCommand<SqlCommand, SqlConnection>(insertStatement, targetConn))
                                    {
                                        for (var i = 0; i < rdr.RowsInBatch; i++)
                                        {
                                            var data = rdr.GetBufferData(i);

                                            try
                                            {
                                                cmd.Parameters.Clear();
                                                for (var j = 0; j < data.Length; j++)
                                                    cmd.Parameters.AddWithValue("@p" + j, data[j]);

                                                cmd.ExecuteNonQuery();
                                            }
                                            catch (Exception ie)
                                            {
                                                if (totalBadRows++ < _totalBadLines)
                                                {
                                                    badFile.Write(data.Aggregate((x, y) => "{0}{1}{2}".FormatWith(x.ToNullString(), _badFileSeparator, y.ToNullString())));
                                                    badFile.WriteLine(",{0}", ie.Message.Trim());
                                                }
                                            }
                                        }
                                    }
                                }

                                rdr.ResetBatch();
                            }
                            while (true);

                            // Get inserted row count.
                            totalRows = GetRowCount(targetTable, null, targetConn);

                            if (badFile == null)
                            {
                                // We finished succesfully.
                                WriteInfo(InfoType.Misc, "Buffered oad for {0} completed.", targetTable);
                            }
                            else
                            {
                                badFile.Close();
                                badFile = null;

                                throw new ApplicationException("Error in data detected. Bad file {0} created. Total errors = {1}".FormatWith(GetBadFileName(targetTable, startTime), totalBadRows));
                            }
                        }
                        else
                        {
                            // No rows in the source. Nothing to do.
                            startTime = DateTime.Now;

                            WriteInfo(InfoType.Misc, "Source table {0} didn't have any rows.", sourceTable);
                        }
                    }
                }
                finally
                {
                    // Record end time.
                    endTime = DateTime.Now;
                }
            }
        }

        /// <summary>
        /// Bulk load a table based on various parameters.
        /// </summary>
        /// <param name="rdrCommand">The reader command to feed the target table with data.</param>
        /// <param name="sourceTable">Souce table name (used for logging and other information.)</param>
        /// <param name="targetConn">Target connection (SqlConnection.)</param>
        /// <param name="targetTable">Target table name (used for logging and other information.)</param>
        /// <param name="commitInterval">Commit interval to use while loading.</param>
        /// <param name="startTime">out parameter to hold the start time of the bulk load.</param>
        /// <param name="endTime">out parameter to hold the end time of the bulk load.</param>
        /// <param name="totalRows">out parameter to hold the total number of rows loaded.</param>
        bool BulkLoadTable(OleDbCommand rdrCommand, string sourceTable, List<Column> sourceColumns, string[] commonColumnNames, SqlConnection targetConn, string targetTable, List<SqlBulkCopyColumnMapping> columnMappings, int commitInterval, out DateTime startTime, out DateTime endTime, out int totalRows)
        {
            // Create the bulk copy object.
            // We are using table locking, keep nulls and internal transaction to ensure speedy and
            // consistent copy.
            using (var bulkCopy = PrepareBulkCopy(targetConn, commitInterval, targetTable, columnMappings))
            {
                // Record start time.
                startTime = DateTime.Now;
                totalRows = 0;

                try
                {
                    // Ensure that we dispose the reader.
                    using (var rdr = new ConvertingReader(rdrCommand.ExecuteReader()))
                    {
                        // Only proceed if we have input rows coming along.
                        // Wont be harmful to proceed, but wasted execution time.
                        if (rdr.HasRows)
                        {
                            // Mark the starting of the main copy routine.
                            WriteInfo(InfoType.Misc, "Load for {0} starting.", targetTable);

                            try
                            {
                                bulkCopy.WriteToServer(rdr);
                            }
                            catch (Exception e)
                            {
                                if (e.Message.Contains("Received an invalid column length from the bcp client"))
                                {
                                    throw;
                                }

                                return false;
                            }

                            // Get inserted row count.
                            totalRows = GetRowCount(targetTable, null, targetConn);
                        }
                        else
                        {
                            // No rows in the source. Nothing to do.
                            startTime = DateTime.Now;

                            WriteInfo(InfoType.Misc, "Source table {0} didn't have any rows.", sourceTable);
                        }

                        return true;
                    }
                }
                finally
                {
                    // Record end time.
                    endTime = DateTime.Now;
                }
            }
        }

        void BulkLoadTable(OleDbCommand rdrCommand, string sourceTable, List<Column> sourceColumns, string[] commonColumnNames, SqlConnection targetConn, string targetTable, List<SqlBulkCopyColumnMapping> columnMappings, int commitInterval)
        {
            DateTime startTime, endTime;
            int totalRows;

            BulkLoadTable(rdrCommand, sourceTable, sourceColumns, commonColumnNames, targetConn, targetTable, columnMappings, commitInterval, out startTime, out endTime, out totalRows);
        }

        void BulkLoadTable(OleDbCommand rdrCommand, string sourceTable, List<Column> sourceColumns, string[] commonColumnNames, SqlConnection targetConn, string targetTable, List<SqlBulkCopyColumnMapping> columnMappings, int commitInterval, out int totalRows)
        {
            DateTime startTime, endTime;

            BulkLoadTable(rdrCommand, sourceTable, sourceColumns, commonColumnNames, targetConn, targetTable, columnMappings, commitInterval, out startTime, out endTime, out totalRows);
        }

        /// <summary>
        /// Mark as thread done executing.
        /// </summary>
        void MarkThreadDoneExecuting(LoadTask loadTask)
        {
            lock (_executingTasks)
            {
                _executingTasks.Remove(loadTask);
                _totalTaskExecuting--;
            }
        }

        private DataRow[] GetRows(DataRowCollection rowsCollection, int start, int maxRows, List<DataRow> rows)
        {
            rows.Clear();

            for (int i = 0; i < maxRows && (start + i) < rowsCollection.Count; i++)
            {
                rows.Add(rowsCollection[start + i]);
            }

            return rows.ToArray();
        }

        private string[] GetCommonColumnNames(List<Column> sourceColumns, List<Column> targetColumns)
        {
            return sourceColumns.Select(c => c.Name).Intersect(targetColumns.Select(c => c.Name), StringComparer.CurrentCultureIgnoreCase).ToArray();
        }

        private string GetBadFileName(string targetTable, DateTime loadStartTime)
        {
            return "{0}_{1}.txt".FormatWith(targetTable.Contains('.') ? targetTable.Split('.')[1] : targetTable, loadStartTime.ToString("yyyyMMdd"));
        }

        private StreamWriter GetBadFileWriter(string targetTable, DateTime loadStartTime)
        {
            return new StreamWriter(
                Path.Combine(
                    _badFilesPath,
                    GetBadFileName(targetTable, loadStartTime)), false);
        }

        private void TruncateTable(string tableName, SqlConnection conn)
        {
            using (var cmd = GetCommand<SqlCommand, SqlConnection>("TRUNCATE TABLE {0}".FormatWith(tableName), conn))
            {
                cmd.ExecuteNonQuery();

                WriteInfo(InfoType.Misc, "Target table {0} has been truncated.", tableName);
            }
        }

        /// <summary>
        /// Thread function to execute a truncate load task.
        /// </summary>
        /// <param name="_loadTask">The task we are going to operate on for the load.</param>
        private void ExecuteTruncateLoadTask(object _loadTask)
        {
            LoadTask loadTask = (LoadTask)_loadTask;

            OleDbConnection sourceConn = null;

            int? truncatedRowCount = null;
            int? importedRowCount = null;
            int totalRows = 0;

            try
            {
                sourceConn = GetConnection<OleDbConnection>("Source");

                // Get row counts. We only proceed if profiling is turned on
                // at the global level and it is not overridden at the load level.
                if (_doProfiling && !(loadTask.OverrideProfiling ?? false))
                {
                    importedRowCount = GetRowCount(loadTask.SourceTable, loadTask.SourceQuery, sourceConn);
                }

                var columnMappings = new List<SqlBulkCopyColumnMapping>();
                var sourceColumnsOverride = "*";
                List<Column> sourceColumns = null;
                List<Column> targetColumns = null;
                string[] commonColumnNames;

                using (var targetOleDbConn = GetConnection<OleDbConnection>("TargetOleDb"))
                {
                    // Check if we have been provided source query. If source query is provided we are going to use it.
                    // Otherwise, we are going to find out own mapping using the source colunmns
                    // or the target table column list.
                    if (loadTask.SourceQuery != null)
                    {
                        using (var cmd = GetCommand<OleDbCommand, OleDbConnection>(loadTask.SourceQuery, sourceConn))
                        {
                            sourceColumns = CollectSchema(cmd);
                        }
                        using (var cmd = GetCommand<OleDbCommand, OleDbConnection>("SELECT * FROM {0}".FormatWith(loadTask.TargetTable), targetOleDbConn))
                        {
                            targetColumns = CollectSchema(cmd);
                        }

                        commonColumnNames = GetCommonColumnNames(sourceColumns, targetColumns);

                        if (commonColumnNames.Length > 0)
                        {
                            foreach (Column sourceColumn in sourceColumns)
                            {
                                foreach (Column targetColumn in targetColumns)
                                {
                                    if (sourceColumn.Name.Equals(targetColumn.Name, StringComparison.CurrentCultureIgnoreCase))
                                    {
                                        if (CanConvertTo(sourceColumn, targetColumn))
                                            columnMappings.Add(new SqlBulkCopyColumnMapping(sourceColumn.Name, targetColumn.Name));
                                        else
                                            throw new ApplicationException(
                                                "Source column {0} doesn't match target column {1}.".FormatWith(sourceColumn, targetColumn));
                                    }
                                }
                            }
                        }
                        else
                        {
                            throw new ApplicationException("No common columns found between source and target.");
                        }
                    }
                    else if (loadTask.SourceColumns != null)
                    {
                        // If source columns is provided, then we use it.
                        var sourceColumnNames = loadTask.SourceColumns.Split(',');
                        var targetColumnNames = loadTask.TargetColumns.Split(',');

                        // Confirm that the mapping beween source columns and the target columns is 1 to 1.
                        // If that is the case the the lenghts will match.
                        if (sourceColumnNames.Length != targetColumnNames.Length)
                        {
                            WriteInfo(InfoType.Error, "Invalid source-to-target mapping specified for load {0}. Skipping load.", loadTask.LoadID);
                            return;
                        }

                        using (var cmd = GetCommand<OleDbCommand, OleDbConnection>("SELECT {0} FROM {1}".FormatWith(loadTask.SourceColumns, loadTask.SourceTable), sourceConn))
                        {
                            sourceColumns = CollectSchema(cmd);
                        }
                        using (var cmd = GetCommand<OleDbCommand, OleDbConnection>("SELECT {0} FROM {1}".FormatWith(loadTask.TargetColumns, loadTask.TargetTable), targetOleDbConn))
                        {
                            targetColumns = CollectSchema(cmd);
                        }

                        // Populate the column mappings to be used for the SqlBulkCopy operation.
                        // It is always a 1-to-1 in order mapping between source and target columns.
                        for (int i = 0; i < sourceColumnNames.Length; i++)
                        {
                            if (CanConvertTo(sourceColumns[i], targetColumns[i]))
                                columnMappings.Add(new SqlBulkCopyColumnMapping(sourceColumnNames[i], targetColumnNames[i]));
                            else
                                throw new ApplicationException(
                                    "Source column {0} doesn't match target column {1}.".FormatWith(sourceColumns[i], targetColumns[i]));
                        }

                        commonColumnNames = targetColumns.Select(x => x.Name).ToArray();
                    }
                    else
                    {
                        // We need to now dynamically find the source and target columns and proceed from there.
                        using (var cmd = GetCommand<OleDbCommand, OleDbConnection>("SELECT * FROM {0}".FormatWith(loadTask.SourceTable), sourceConn))
                        {
                            sourceColumns = CollectSchema(cmd);
                        }
                        using (var cmd = GetCommand<OleDbCommand, OleDbConnection>("SELECT * FROM {0}".FormatWith(loadTask.TargetTable), targetOleDbConn))
                        {
                            targetColumns = CollectSchema(cmd);
                        }

                        commonColumnNames = GetCommonColumnNames(sourceColumns, targetColumns);

                        if (commonColumnNames.Count() > 0)
                        {
                            foreach (var col in commonColumnNames)
                            {
                                var sourceColumn = sourceColumns.Where(nt => nt.Name.Equals(col, StringComparison.CurrentCultureIgnoreCase)).Single();
                                var targetColumn = targetColumns.Where(nt => nt.Name.Equals(col, StringComparison.CurrentCultureIgnoreCase)).Single();

                                if (CanConvertTo(sourceColumn, targetColumn))
                                    columnMappings.Add(new SqlBulkCopyColumnMapping(sourceColumn.Name, targetColumn.Name));
                                else
                                    throw new ApplicationException(
                                        "Source column {0} doesn't match target column {1}.".FormatWith(sourceColumn, targetColumn));
                            }

                            sourceColumnsOverride = commonColumnNames.Aggregate((x, y) => x + "," + y);
                        }
                        else
                            throw new ApplicationException("No common columns found between source and target.");
                    }
                }

                if (loadTask.SourceActualColumns != null)
                {
                    if (sourceColumns.Select(x => x.Name).Intersect(loadTask.SourceActualColumns.Split(',')).Count() !=
                        sourceColumns.Count())
                        throw new ApplicationException("Source columns have changed from the last load.");
                }

                if (loadTask.TargetActualColumns != null)
                {
                    if (targetColumns.Select(x => x.Name).Intersect(loadTask.TargetActualColumns.Split(',')).Count() !=
                        targetColumns.Count())
                        throw new ApplicationException("Target columns have changed from the last load.");
                }

                DateTime startTime, endTime;
                TimeSpan timeTaken;

                bool status;


                // This is our source command. We will open a reader on it to fetch data.
                using (var readCmd = GetCommand<OleDbCommand, OleDbConnection>(loadTask.SourceQuery ?? "SELECT {0} FROM {1}".FormatWith(loadTask.SourceColumns ?? sourceColumnsOverride, loadTask.SourceTable), sourceConn))
                {
                    using (var targetConn = GetConnection<SqlConnection>("Target"))
                    {
                        truncatedRowCount = GetRowCount(loadTask.TargetTable, null, targetConn);

                        // Truncate the target table.
                        TruncateTable(loadTask.TargetTable, targetConn);

                        // Call the bulk load table function to do our bulk load.
                        status = BulkLoadTable(
                            readCmd,
                            loadTask.SourceTable,
                            sourceColumns,
                            commonColumnNames,
                            targetConn,
                            loadTask.TargetTable,
                            columnMappings,
                            loadTask.CommitInterval ?? this._commitInterval,
                            out startTime,
                            out endTime,
                            out totalRows);
                    }
                }

                if (!status)
                {
                    using (var readCmd = GetCommand<OleDbCommand, OleDbConnection>(loadTask.SourceQuery ?? "SELECT {0} FROM {1}".FormatWith(loadTask.SourceColumns ?? sourceColumnsOverride, loadTask.SourceTable), sourceConn))
                    {
                        using (var targetConn = GetConnection<SqlConnection>("Target"))
                        {
                            TruncateTable(loadTask.TargetTable, targetConn);

                            BufferedBulkLoadTable(
                                readCmd,
                                loadTask.SourceTable,
                                sourceColumns,
                                commonColumnNames,
                                targetConn,
                                loadTask.TargetTable,
                                columnMappings,
                                _bufferLength,
                                out startTime,
                                out endTime,
                                out totalRows);
                        }
                    }
                }

                // Calculate our elapsed time.
                timeTaken = endTime - startTime;

                // Log information about the current completed load.
                WriteInfo(
                    InfoType.Load,
                    "{0} rows loaded {1}: source {2}->target {3} in {4}.",
                    totalRows,
                    loadTask.LoadID,
                    loadTask.SourceTable,
                    loadTask.TargetTable,
                    timeTaken);

                UpdateLoadColumns(loadTask, sourceColumns, targetColumns);

                // Log the successful load.
                LogSuccessEntry(
                    _packageName,
                    _taskName,
                    _version,
                    loadTask.TargetTable,
                    importedRowCount ?? totalRows,
                    totalRows,
                    truncatedRowCount,
                    null, // No updates
                    startTime,
                    endTime,
                    timeTaken);
            }
            catch (Exception e)
            {
                // We have encountered a failure.
                WriteInfo(InfoType.Error, "Error in loading task {0}: {1}", loadTask.LoadID, e.Message);

                // Log the error.
                LogErrorEntry(
                    _packageName,
                    _taskName,
                    _version,
                    loadTask.TargetTable,
                    String.Empty,
                    e.Message + e.StackTrace,
                    DateTime.Now);

                Interlocked.Increment(ref _totalTableFailures);
            }
            finally
            {
                CloseConnection(ref sourceConn);

                // We are done executing.
                MarkThreadDoneExecuting(loadTask);

                // Increase global row count.
                Thread.VolatileWrite(ref _globalTotalRows, _globalTotalRows + totalRows);

                GC.Collect();
            }
        }

        void ExecuteDeleteLoadTask(object _loadTask)
        {
            //LoadTask loadTask = (LoadTask)_loadTask;

            //OleDbConnection sourceConn;
            //SqlConnection targetConn;
            //OleDbConnection targetOleDbConn;

            //int? importedRowCount = null;
            //var totalRows = 0;

            //sourceConn = GetConnection<OleDbConnection>("Source");
            //targetConn = GetConnection<SqlConnection>("Target");
            //targetOleDbConn = GetConnection<OleDbConnection>("TargetOleDb");

            //try
            //{
            //    // Get row counts.
            //    if (_doProfiling)
            //        importedRowCount = GetRowCount(loadTask.SourceTable, loadTask.SourceQuery, sourceConn);

            //    // Mark start time.
            //    DateTime startTime = DateTime.Now;

            //    // Get the max updated date from target table.
            //    string maxUpdatedDate;

            //    using (var getMaxUpdatedDateCmd = new SqlCommand(loadTask.GetMaxDateQuery, targetConn))
            //    {
            //        maxUpdatedDate = getMaxUpdatedDateCmd.ExecuteScalar().ToString();
            //    }

            //    // Copy the new rows based on obtained update date from source table to temp table.
            //    var readSourceDataCmd = new OleDbCommand(loadTask.ReadSourceDataQuery.FormatWith(maxUpdatedDate), sourceConn);

            //    BulkLoadTable(
            //        readSourceDataCmd,
            //        loadTask.SourceTable,
            //        targetConn,
            //        loadTask.TmpTargetTable,
            //        null,
            //        loadTask.CommitInterval ?? _commitInterval);

            //    // Delete matching rows from target table based on temp table.
            //    int totalRowsDeleted;

            //    using (var deleteMatchingRowsCmd = new SqlCommand(loadTask.DeleteDataTargetQuery, targetConn))
            //    {
            //        totalRowsDeleted = (int)deleteMatchingRowsCmd.ExecuteScalar();
            //    }

            //    // Copy data from temp table to target table.
            //    var readDataFromTmpTableCmd = GetCommand<OleDbCommand, OleDbConnection>("SELECT * FROM " + loadTask.TargetTable, targetOleDbConn);

            //    BulkLoadTable(
            //        readDataFromTmpTableCmd,
            //        loadTask.TmpTargetTable,
            //        targetConn,
            //        loadTask.TargetTable,
            //        null,
            //        loadTask.CommitInterval ?? _commitInterval,
            //        out totalRows);

            //    // Mark end time.
            //    DateTime endTime = DateTime.Now;

            //    TimeSpan timeTaken = endTime - startTime;

            //    WriteInfo(
            //        InfoType.Load,
            //        "{0} rows loaded source {1}->target {2} in {3}.",
            //        totalRows,
            //        loadTask.SourceTable,
            //        loadTask.TargetTable,
            //        timeTaken);

            //    LogSuccessEntry(
            //        _packageName,
            //        _taskName,
            //        _version,
            //        loadTask.TargetTable,
            //        importedRowCount,
            //        totalRows,
            //        null,
            //        totalRowsDeleted, // No updates
            //        startTime,
            //        endTime,
            //        timeTaken);

            //}
            //catch (Exception e)
            //{
            //    // We have encountered a failure.
            //    WriteInfo(InfoType.Error, "Error in loading task {0}: {1}", loadTask.LoadID, e.Message);

            //    // Log the error.
            //    LogErrorEntry(
            //        _packageName,
            //        _taskName,
            //        _version,
            //        loadTask.TargetTable,
            //        String.Empty,
            //        e.Message,
            //        DateTime.Now);
            //}
            //finally
            //{
            //    // We are done executing.
            //    MarkThreadDoneExecuting(loadTask);

            //    // Increase global row count.
            //    Thread.VolatileWrite(ref _globalTotalRows, _globalTotalRows + totalRows);
            //}
        }

        /// <summary>
        /// The logging data context.
        /// </summary>
        LoggingDataContext _loggingDataContext;

        int _totalErrors;
        int _totalTableFailures;

        /// <summary>
        /// Initialize the logging system.
        /// </summary>
        private void InitializeLogging()
        {
            _loggingDataContext = new LoggingDataContext(ResolveConnString(_loggingTableConn));
        }

        public void LogSuccessEntry(string packageName, string taskName, string version, string tableName, int? importedRowCount, int? insertedRowCount, int? delTruncRowCount, int? updatedRowCount, DateTime? startTime, DateTime? endTime, TimeSpan? elapsedTime)
        {
            lock (_loggingDataContext)
            {
                _loggingDataContext.Successes.InsertOnSubmit(
                    new Success()
                    {
                        Package_Name = packageName,
                        Task_Name = String.Format("{0}:{1}", taskName, tableName),
                        Version = version,
                        Imported_RowCount = importedRowCount,
                        Inserted_RowCount = insertedRowCount,
                        Del_Trunc_RowCount = delTruncRowCount,
                        Updated_RowCount = updatedRowCount,
                        Starttime = startTime,
                        Endtime = endTime,
                        ElapsedTime = elapsedTime.ToString()
                    });
            }
        }

        public void LogErrorEntry(string packageName, string taskName, string version, string tableName, string errorNum, string errorDesc, DateTime? errorTime)
        {
            lock (_loggingDataContext)
            {
                _loggingDataContext.Failures.InsertOnSubmit(
                    new Failure()
                    {
                        Package_Name = packageName,
                        Task_Name = "{0}:{1}".FormatWith(taskName, tableName),
                        Version = version,
                        Error_Num = errorNum,
                        Error_Desc = errorDesc,
                        Error_Time = errorTime
                    });
            }
        }

        /// <summary>
        /// Shut down the logging system.
        /// </summary>
        private void ShutdownLogging()
        {
            _loggingDataContext.SubmitChanges();

            _loggingDataContext.Dispose();
            _loggingDataContext = null;
        }

        LoadingDataContext _loadingDataContext;

        /// <summary>
        /// Initialize the loading system.
        /// </summary>
        private void InitializeLoading()
        {
            // Make sure we dispose of the loading data context.
            _loadingDataContext = new LoadingDataContext(ResolveConnString(_loadingTableConn));

            // LINQ to SQL query to get the load tasks.
            // The load task must be enabled (Enabled == True) and must be from the proper batch.
            // They are ordered based on priority and load id.
            _loadTasks = new Queue<LoadTask>(from x in _loadingDataContext.LoadTasks
                                             where x.Enabled == true && x.BatchID == _batchId
                                             orderby (x.Priority ?? 0) descending
                                             select x);

            _conversions = new List<Conversion>(_loadingDataContext.Conversions);

            // Log information about number of tasks retrieved.
            WriteInfo(InfoType.Load, "We have been given {0} task(s). We will execute these tasks using {1} thread(s).", _loadTasks.Count, _totalThreads);
            WriteInfo(InfoType.Misc, "Closing connection to meta table.");
        }

        private void ShutdownLoading()
        {
            _loadingDataContext.SubmitChanges();

            _loadingDataContext.Dispose();
            _loadingDataContext = null;
        }

        private void UpdateLoadColumns(LoadTask loadTask, List<Column> sourceColumns, List<Column> targetColumns)
        {
            loadTask.SourceActualColumns = sourceColumns.Select(x => x.Name).Aggregate((y, z) => y + "," + z);
            loadTask.TargetActualColumns = targetColumns.Select(x => x.Name).Aggregate((y, z) => y + "," + z);
        }

        /// <summary>
        /// Total rows loaded in this session.
        /// </summary>
        int _globalTotalRows = 0;

        /// <summary>
        /// Total number of tasks executing.
        /// </summary>
        int _totalTaskExecuting = 0;

        List<LoadTask> _executingTasks = new List<LoadTask>();

        List<LoadTask> _scheduledTasks = new List<LoadTask>();

        /// <summary>
        /// Which task to execute next.
        /// </summary>
        /// <returns>Next load task to execute.</returns>
        private LoadTask GetNextTaskToExecute()
        {
            var loadTask = _loadTasks.Dequeue();
            _scheduledTasks.Add(loadTask);

            return loadTask;
        }

        /// <summary>
        /// Tells us if more tasks remain in the queue.
        /// </summary>
        /// <returns>True if more tasks are there to execute.</returns> 
        private bool MoreTasksRemain()
        {
            return _loadTasks.Count > 0;
        }

        /// <summary>
        /// Our main routine.
        /// </summary>
        public void Main()
        {
            // Initialize the variables from SSIS.
            InitVariables();

            // Initialize the table logging system.
            InitializeLogging();

            // Get loading meta data.
            InitializeLoading();

            // Record the start time.
            var startTime = DateTime.Now;
            var totalTables = _loadTasks.Count;

            // Schedule jobs.
            while (MoreTasksRemain())
            {
                // Check if we are running at max number of tasks.
                if (_totalTaskExecuting >= _totalThreads)
                {
                    // Nothing to schedule, lets idle for 500 msec.
                    Thread.Sleep(500);
                }
                else
                {
                    // We have a job to schedule. Increase the total threads executing.
                    Thread thread;

                    // Get the next task to execute.
                    var taskToExecute = GetNextTaskToExecute();

                    lock (_executingTasks)
                    {
                        _executingTasks.Add(taskToExecute);
                        _totalTaskExecuting++;
                    }

                    // Decide on how to process the task. If it is a delete load, then we will use
                    // the ExecuteDeleteLoadTask routine to process the load. Otherwise we use the
                    // ExecuteTruncateLoadTask routine to proceed.
                    if ((taskToExecute.IsDeleteLoad ?? false) || taskToExecute.DeleteDataTargetQuery != null)
                        thread = new Thread(ExecuteDeleteLoadTask);
                    else
                        thread = new Thread(ExecuteTruncateLoadTask);

                    WriteInfo(
                        InfoType.Load,
                        "Scheduling load for target {0}: {1}...",
                        taskToExecute.LoadID,
                        taskToExecute.TargetTable);

                    // Start execution of thread.
                    thread.Start(taskToExecute);
                }
            }

            var waitLoopCount = 0;

            // All jobs scheduled.
            while (true)
            {
                lock (_executingTasks)
                {
                    if (_executingTasks.Count > 0)
                    {
                        waitLoopCount++;

                        if (waitLoopCount % 60 == 0)
                        {
                            waitLoopCount = 0;

                            WriteInfo(
                                InfoType.Load,
                                "{0} job(s) still waiting to finish. {1} rows loaded so far.".FormatWith(_executingTasks.Count, _globalTotalRows));
                            WriteInfo(
                                InfoType.Load,
                                "Jobs executing are: {0}".FormatWith(_executingTasks.Take(5).Select(t => t.SourceTable).Aggregate((x, y) => x + ", " + y)));
                        }
                    }
                    else
                        break;
                }

                // Wait 500 msec to check again.
                Thread.Sleep(500);
            }

            // Record the end time.
            DateTime endTime = DateTime.Now;

            // Total time taken.
            TimeSpan timeTaken = endTime - startTime;

            // Mark as success or failure.
            if (_totalTableFailures > ((_errorThreshold / 100.0) * totalTables))
                Dts.TaskResult = (int)ScriptResults.Failure;
            else
            {
                // Log information for the completed session.
                WriteInfo(InfoType.Load, "{0} table loads completed in {1} using {2} parallel threads.", totalTables, timeTaken.ToString(), _totalThreads);
                WriteInfo(InfoType.Load, "{0} rows were loaded in {1}. Thats {2} rows/sec.", _globalTotalRows, timeTaken, Math.Round(_globalTotalRows / timeTaken.TotalSeconds));

                Dts.TaskResult = (int)ScriptResults.Success;
            }

            // Shutdown logging system.
            ShutdownLogging();

            ShutdownLoading();
        }
    }
}